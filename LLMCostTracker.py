from typing import TypedDict, List
import tiktoken


class LLMCallData(TypedDict):
    total_cost: float
    input_tokens: int
    output_tokens: int

class LLMCostTracker:
    """A class to track and accumulate cost and token usage data for multiple LLM calls."""

    def __init__(self):
        """Initialize an empty list to store individual LLM call data."""

        self.calls = []

    def add_call(self, cb):
        """
        Add a single LLM call's cost and token data to the tracker.

        Args:
            total_cost (float): The cost associated with this LLM call.
            input_tokens (int): The number of input tokens used in this call.
            output_tokens (int): The number of output tokens generated by this call.
        """
        call_data = LLMCallData(
            total_cost=cb.total_cost,
            input_tokens=cb.prompt_tokens,
            output_tokens=cb.completion_tokens
        )
        self.calls.append(call_data)

    
    def get_totals(self) -> LLMCallData:
        """
        Calculate and return the total cost and tokens for all tracked LLM calls.

        Returns:
            LLMCallData: A dictionary containing the accumulated total cost, input tokens, and output tokens.
        """
        return LLMCallData(
            total_cost=sum(call["total_cost"] for call in self.calls),
            input_tokens=sum(call["input_tokens"] for call in self.calls),
            output_tokens=sum(call["output_tokens"] for call in self.calls)
        )
    
    @staticmethod
    def add_two_llm_call_data(data1: LLMCallData, data2: LLMCallData) -> LLMCallData:
        """
        Add two LLMCallData instances together.

        Args:
            data1 (LLMCallData): The first LLM call data dictionary.
            data2 (LLMCallData): The second LLM call data dictionary.

        Returns:
            LLMCallData: A new LLMCallData dictionary with each field summed.
        """
        return LLMCallData(
            total_cost=data1['total_cost'] + data2['total_cost'],
            input_tokens=data1['input_tokens'] + data2['input_tokens'],
            output_tokens=data1['output_tokens'] + data2['output_tokens']
        )

    @staticmethod
    def add_list_llm_call_data(data_list: List[LLMCallData]) -> LLMCallData:
        """
        Accumulate a list of LLMCallData instances into a single total.

        Args:
            data_list (List[LLMCallData]): A list of LLM call data dictionaries to be summed.

        Returns:
            LLMCallData: A dictionary containing the accumulated total cost, input tokens, and output tokens for all calls in the list.
        """
        total_data = LLMCallData(total_cost=0.0, input_tokens=0, output_tokens=0)
        for data in data_list:
            total_data = LLMCostTracker.add_two_llm_call_data(total_data, data)
        
        return total_data
        


class EmbeddingCostCalculator:
    def __init__(self, model_name="text-embedding-3-large"):
        """
        Initialize the CostCalculator with a model name and cost per 1,000 tokens.

        Args:
            model_name (str): The embedding model for tokenization. Defaults to "text-embedding-3-large".

        Raises:
            ValueError: If the provided model name is not found in the cost data.
        """
        embedding_costs_per_1000 = {
            "text-embedding-3-small": {"input": 0.00002, "output": 0.00001},
            "text-embedding-3-large": {"input": 0.00013, "output": 0.000065},
            "ada-v2": {"input": 0.0001, "output": 0.00005}
        }
        if model_name not in embedding_costs_per_1000:
            raise ValueError(f"Model name '{model_name}' not found in the cost data.")

        self.model_name = model_name
        self.cost_per_1000_tokens = embedding_costs_per_1000[model_name]
        self.encoding = None
        self.paragraphs = None  # Placeholder for paragraphs

    def __enter__(self):
        """Initialize the tokenizer encoding for the model."""
        self.encoding = tiktoken.encoding_for_model(self.model_name)
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Clean up resources."""
        self.encoding = None

    def __call__(self, paragraphs):
        """
        Calculate the cost based on the provided paragraphs.

        Args:
            paragraphs (list of dict): List of document chunks or paragraphs.
        """
        self.paragraphs = paragraphs
        total_tokens = sum(len(self.encoding.encode(paragraph.page_content)) for paragraph in paragraphs)
        total_cost = (total_tokens / 1000) * self.cost_per_1000_tokens["input"]
        self.embedding_cost_summary = {
            "model_name": self.model_name,
            "total_tokens": total_tokens,
            "total_cost": round(total_cost, 2)
        }

    def add_documents_with_cost(self, index, documents):
        """
        Calculate cost and add documents to the index, handling cost calculation internally.

        Args:
            index (Index): The index where documents will be added.
            documents (list of dict): List of document chunks or paragraphs.
        """
        self.__call__(documents)
        index.add_documents(documents)
        print("Embedding Cost Summary:", self.embedding_cost_summary)
